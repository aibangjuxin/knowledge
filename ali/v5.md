主要修改内容：

重命名函数：

get_readiness_urls() → show_readiness_probe_urls()
现在只显示 readiness probe URLs，不返回用于测试
分离测试逻辑：

Ingress URLs：实际进行 HTTP 测试（因为这些是入口点，应该可访问）
Readiness probe URLs：仅显示供参考，不进行测试（因为可能不通或需要内部访问）
优化输出：

Readiness probe URLs 用 📋 图标标识，明确标注为"reference only, not tested"
Ingress URLs 用 🌐 图标标识，这些会被实际测试
测试结果明确说明只测试了 Ingress URLs
简化流程：

只有 Ingress URLs 参与实际的 HTTP 测试
Readiness probe URLs 作为额外信息展示，帮助理解应用的健康检查端点
这样脚本会：

显示完整的资源关系映射
展示潜在的 readiness probe URLs（仅供参考）
只对 Ingress URLs 进行实际的 HTTP 测试
简化了测试流程，避免了可能不通的 readiness probe 测试
- v5.sh
```bash
#!/bin/bash
# E2E Verification Script for Kubernetes Resources
# Usage: ./verify-e2e.sh -n <namespace>

# set -e  # Commented out to prevent script from exiting on non-critical errors

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
NAMESPACE=""
TIMEOUT=10

# Function to print colored output
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to show usage
usage() {
    echo "Usage: $0 -n <namespace> [-t <timeout>]"
    echo "  -n: Kubernetes namespace (required)"
    echo "  -t: Timeout for curl requests in seconds (default: 10)"
    echo "  -h: Show this help message"
    exit 1
}

# Parse command line arguments
while getopts "n:t:h" opt; do
    case $opt in
        n)
            NAMESPACE="$OPTARG"
            ;;
        t)
            TIMEOUT="$OPTARG"
            ;;
        h)
            usage
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            usage
            ;;
    esac
done

# Check if namespace is provided
if [ -z "$NAMESPACE" ]; then
    print_error "Namespace is required!"
    usage
fi

# Check if kubectl is available
if ! command -v kubectl &> /dev/null; then
    print_error "kubectl is not installed or not in PATH"
    exit 1
fi

# Check if jq is available
if ! command -v jq &> /dev/null; then
    print_error "jq is not installed or not in PATH"
    exit 1
fi

# Check if namespace exists
if ! kubectl get namespace "$NAMESPACE" &> /dev/null; then
    print_error "Namespace '$NAMESPACE' does not exist"
    exit 1
fi

print_info "Starting E2E verification for namespace: $NAMESPACE"
echo "=================================================="

# Function to extract URLs from Ingress
get_ingress_urls() {
    print_info "Extracting URLs from Ingress resources..."

    local ingress_urls=()
    local ingresses
    
    # Get ingresses with error handling
    if ! ingresses=$(kubectl get ingress -n "$NAMESPACE" -o json 2>/dev/null); then
        print_warning "Failed to get Ingress resources from namespace $NAMESPACE"
        return
    fi

    local ingress_count=$(echo "$ingresses" | jq '.items | length' 2>/dev/null || echo "0")
    if [ "$ingress_count" -eq 0 ]; then
        print_warning "No Ingress resources found in namespace $NAMESPACE"
        return
    fi

    print_info "Found $ingress_count Ingress resources"

    # Extract hosts and paths from ingress with better error handling
    while IFS= read -r line; do
        if [ -n "$line" ] && [ "$line" != "null" ]; then
            ingress_urls+=("$line")
        fi
    done < <(echo "$ingresses" | jq -r '.items[] |
        .spec.rules[]? |
        select(.host != null) |
        "https://" + .host + (.http.paths[]?.path // "")' 2>/dev/null || true)

    print_info "Extracted ${#ingress_urls[@]} URLs from Ingress resources"
    printf '%s\n' "${ingress_urls[@]}"
}

# Function to build and display resource relationships (no URL testing)
show_resource_relationships_detailed() {
    print_info "Building detailed resource relationship map..."

    # Create temporary files for data processing
    local temp_dir="/tmp/verify-e2e-$$"
    mkdir -p "$temp_dir"
    local ingress_data="$temp_dir/ingress.json"
    local service_data="$temp_dir/services.json"
    local deployment_data="$temp_dir/deployments.json"
    local relationship_output="$temp_dir/relationships.txt"

    # Fetch all resources with error handling
    if ! kubectl get ingress -n "$NAMESPACE" -o json > "$ingress_data" 2>/dev/null; then
        print_warning "Failed to fetch ingress data"
        rm -rf "$temp_dir"
        return
    fi

    if ! kubectl get services -n "$NAMESPACE" -o json > "$service_data" 2>/dev/null; then
        print_warning "Failed to fetch service data"
        rm -rf "$temp_dir"
        return
    fi

    if ! kubectl get deployments -n "$NAMESPACE" -o json > "$deployment_data" 2>/dev/null; then
        print_warning "Failed to fetch deployment data"
        rm -rf "$temp_dir"
        return
    fi

    # Check if we have any ingresses
    local ingress_count=$(jq '.items | length' "$ingress_data" 2>/dev/null || echo "0")
    if [ "$ingress_count" -eq 0 ]; then
        print_warning "No Ingress resources found in namespace $NAMESPACE"
        rm -rf "$temp_dir"
        return
    fi

    print_info "Processing $ingress_count Ingress resources for relationship mapping..."

    # Build resource relationship map using jq (only for relationship display, no URL generation)
    jq -r --slurpfile services "$service_data" --slurpfile deployments "$deployment_data" '
    .items[] as $ingress |
    $ingress.metadata.name as $ingress_name |
    
    $ingress.spec.rules[]? as $rule |
    $rule.host as $host |
    
    if ($host and $host != null) then
        $rule.http.paths[]? as $path |
        
        ($path.path // "/") as $ingress_path |
        ($path.backend.service.name // $path.backend.serviceName // empty) as $service_name |
        ($path.backend.service.port.number // $path.backend.servicePort // empty) as $service_port |
        
        if ($service_name and $service_name != null) then
            # Find matching service
            $services[0].items[] | select(.metadata.name == $service_name) as $service |
            
            if ($service) then
                $service.spec.selector as $selector |
                
                if ($selector and ($selector | length > 0)) then
                    # Find matching deployments
                    $deployments[0].items[] as $deployment |
                    $deployment.metadata.name as $deployment_name |
                    $deployment.spec.template.metadata.labels as $deploy_labels |
                    
                    if ($deploy_labels) then
                        # Check if deployment labels match service selector
                        ([$selector | to_entries[] as $sel_entry | 
                         $deploy_labels[$sel_entry.key] == $sel_entry.value] | all) as $labels_match |
                        
                        if ($labels_match) then
                            # Show relationship mapping
                            "✓ \($ingress_name) (\($host)\($ingress_path)) -> \($service_name):\($service_port) -> \($deployment_name)"
                        else 
                            "⚠ \($ingress_name) (\($host)\($ingress_path)) -> \($service_name):\($service_port) -> [NO MATCHING DEPLOYMENT]"
                        end
                    else 
                        "⚠ \($ingress_name) (\($host)\($ingress_path)) -> \($service_name):\($service_port) -> [DEPLOYMENT HAS NO LABELS]"
                    end
                else 
                    "⚠ \($ingress_name) (\($host)\($ingress_path)) -> \($service_name):\($service_port) -> [SERVICE HAS NO SELECTOR]"
                end
            else 
                "✗ \($ingress_name) (\($host)\($ingress_path)) -> \($service_name) [SERVICE NOT FOUND]"
            end
        else 
            "✗ \($ingress_name) (\($host)\($ingress_path)) -> [NO SERVICE SPECIFIED]"
        end
    else 
        "✗ \($ingress_name) [NO HOST SPECIFIED]"
    end
    ' "$ingress_data" > "$relationship_output" 2>/dev/null

    # Display the relationships
    echo
    print_info "Resource Relationship Map:"
    echo "=================================================="
    while IFS= read -r line; do
        if [ -n "$line" ]; then
            if [[ "$line" == ✓* ]]; then
                print_success "$line"
            elif [[ "$line" == ⚠* ]]; then
                print_warning "$line"
            elif [[ "$line" == ✗* ]]; then
                print_error "$line"
            else
                echo "$line"
            fi
        fi
    done < "$relationship_output"
    echo "=================================================="

    # Clean up temporary files
    rm -rf "$temp_dir"
}

# Function to display potential readiness probe URLs (no testing, just display)
show_readiness_probe_urls() {
    print_info "Discovering potential readiness probe URLs (for reference only)..."

    # Create temporary files for data processing
    local temp_dir="/tmp/verify-e2e-$$"
    mkdir -p "$temp_dir"
    local ingress_data="$temp_dir/ingress.json"
    local service_data="$temp_dir/services.json"
    local deployment_data="$temp_dir/deployments.json"
    local url_output="$temp_dir/readiness_urls.txt"

    # Fetch all resources with error handling
    if ! kubectl get ingress -n "$NAMESPACE" -o json > "$ingress_data" 2>/dev/null; then
        print_warning "Failed to fetch ingress data"
        rm -rf "$temp_dir"
        return
    fi

    if ! kubectl get services -n "$NAMESPACE" -o json > "$service_data" 2>/dev/null; then
        print_warning "Failed to fetch service data"
        rm -rf "$temp_dir"
        return
    fi

    if ! kubectl get deployments -n "$NAMESPACE" -o json > "$deployment_data" 2>/dev/null; then
        print_warning "Failed to fetch deployment data"
        rm -rf "$temp_dir"
        return
    fi

    # Check if we have any ingresses
    local ingress_count=$(jq '.items | length' "$ingress_data" 2>/dev/null || echo "0")
    if [ "$ingress_count" -eq 0 ]; then
        print_warning "No Ingress resources found in namespace $NAMESPACE"
        rm -rf "$temp_dir"
        return
    fi

    # Build readiness probe URLs using jq
    jq -r --slurpfile services "$service_data" --slurpfile deployments "$deployment_data" '
    .items[] as $ingress |
    $ingress.metadata.name as $ingress_name |
    
    $ingress.spec.rules[]? as $rule |
    $rule.host as $host |
    
    if ($host and $host != null) then
        $rule.http.paths[]? as $path |
        
        ($path.path // "/") as $ingress_path |
        ($path.backend.service.name // $path.backend.serviceName // empty) as $service_name |
        ($path.backend.service.port.number // $path.backend.servicePort // empty) as $service_port |
        
        if ($service_name and $service_name != null) then
            # Find matching service
            $services[0].items[] | select(.metadata.name == $service_name) as $service |
            
            if ($service) then
                $service.spec.selector as $selector |
                
                if ($selector and ($selector | length > 0)) then
                    # Find matching deployments
                    $deployments[0].items[] as $deployment |
                    $deployment.metadata.name as $deployment_name |
                    $deployment.spec.template.metadata.labels as $deploy_labels |
                    
                    if ($deploy_labels) then
                        # Check if deployment labels match service selector
                        ([$selector | to_entries[] as $sel_entry | 
                         $deploy_labels[$sel_entry.key] == $sel_entry.value] | all) as $labels_match |
                        
                        if ($labels_match) then
                            # Extract readiness probe paths from deployment
                            $deployment.spec.template.spec.containers[]? as $container |
                            
                            if ($container.readinessProbe and $container.readinessProbe.httpGet) then
                                $container.readinessProbe.httpGet.path as $probe_path |
                                ($container.readinessProbe.httpGet.port // 80) as $probe_port |
                                
                                if ($probe_path and $probe_path != "/" and $probe_path != null) then
                                    "https://\($host)\($probe_path)"
                                else empty end
                            else empty end
                        else empty end
                    else empty end
                else empty end
            else empty end
        else empty end
    else empty end
    ' "$ingress_data" > "$url_output" 2>/dev/null

    # Display the readiness probe URLs (no testing)
    local readiness_count=0
    echo
    print_info "Potential E2E Readiness Probe URLs (reference only, not tested):"
    echo "=================================================================="
    while IFS= read -r line; do
        if [ -n "$line" ]; then
            echo "  📋 $line"
            ((readiness_count++))
        fi
    done < <(sort -u "$url_output" 2>/dev/null)
    
    if [ $readiness_count -eq 0 ]; then
        print_warning "No readiness probe URLs found"
    else
        print_info "Found $readiness_count potential readiness probe URLs"
    fi
    echo "=================================================================="

    # Clean up temporary files
    rm -rf "$temp_dir"
}

# Function to test a single URL
test_url() {
    local url="$1"
    printf "Testing %-60s ... " "$url"
    
    # Get HTTP status code
    local status_code
    if status_code=$(curl --silent --head --insecure --connect-timeout "$TIMEOUT" --max-time "$TIMEOUT" --write-out "%{http_code}" --output /dev/null "$url" 2>/dev/null); then
        # Consider 5xx as failure, everything else as success
        if [[ "$status_code" =~ ^5[0-9][0-9]$ ]]; then
            print_error "✗ $status_code"
            return 1
        elif [[ "$status_code" =~ ^[23][0-9][0-9]$ ]]; then
            print_success "✓ $status_code"
            return 0
        elif [[ "$status_code" =~ ^4[0-9][0-9]$ ]]; then
            print_warning "! $status_code (Client Error)"
            return 0  # Consider 4xx as success for readiness probes (might be auth-protected)
        else
            print_warning "? $status_code (Unknown)"
            return 0
        fi
    else
        print_error "✗ TIMEOUT/ERROR"
        return 1
    fi
}

# Function to show resource summary
show_resource_summary() {
    print_info "Resource summary for namespace $NAMESPACE:"
    
    local ingress_count=$(kubectl get ingress -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
    local service_count=$(kubectl get services -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
    local deployment_count=$(kubectl get deployments -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
    local pod_count=$(kubectl get pods -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
    local rs_count=$(kubectl get replicasets -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l)
    
    echo "  Ingresses: $ingress_count"
    echo "  Services: $service_count"
    echo "  Deployments: $deployment_count"
    echo "  Pods: $pod_count"
    echo "  ReplicaSets: $rs_count"
    echo
}

# Function to show pod status
show_pod_status() {
    print_info "Pod status in namespace $NAMESPACE:"
    if ! kubectl get pods -n "$NAMESPACE" -o wide 2>/dev/null; then
        print_warning "Could not get pod status"
    fi
    echo
}

# Function to show basic resource relationships (simple version)
show_resource_relationships() {
    print_info "Basic resource relationships in namespace $NAMESPACE:"
    
    # Get ingress to service mappings
    kubectl get ingress -n "$NAMESPACE" -o json 2>/dev/null | jq -r '
    .items[] as $ingress |
    $ingress.metadata.name as $ingress_name |
    $ingress.spec.rules[]? as $rule |
    $rule.host as $host |
    $rule.http.paths[]? as $path |
    ($path.backend.service.name // $path.backend.serviceName) as $service_name |
    ($path.path // "/") as $path_value |
    "  \($ingress_name) (\($host)\($path_value)) -> \($service_name)"
    ' 2>/dev/null || print_warning "Could not analyze ingress relationships"
    
    echo
}

# Main logic
main() {
    # Show resource summary
    show_resource_summary

    # Show basic resource relationships
    show_resource_relationships

    # Show detailed resource relationships (no testing, just mapping)
    show_resource_relationships_detailed

    # Show pod status
    show_pod_status

    # Show potential readiness probe URLs (display only, no testing)
    show_readiness_probe_urls

    # Get URLs for actual testing (only ingress URLs)
    print_info "Collecting Ingress URLs for testing..."
    echo "=================================================="
    
    local ingress_urls=$(get_ingress_urls)
    echo

    # Prepare URLs for testing (only ingress URLs)
    local test_urls=()
    
    # Add ingress URLs for testing
    while IFS= read -r url; do 
        [ -n "$url" ] && test_urls+=("$url")
    done <<< "$ingress_urls"
    
    # Remove duplicates
    if [ ${#test_urls[@]} -gt 0 ]; then
        local unique_test_urls=()
        while IFS= read -r url; do
            unique_test_urls+=("$url")
        done < <(printf '%s\n' "${test_urls[@]}" | sort -u)
        test_urls=("${unique_test_urls[@]}")
    fi

    if [ ${#test_urls[@]} -eq 0 ]; then
        print_warning "No Ingress URLs found to test."
        print_info "This might indicate:"
        print_info "  1. No Ingress resources with valid hosts"
        print_info "  2. Ingress resources are not properly configured"
        exit 0
    fi

    print_info "Ingress URLs to be tested:"
    printf -- "  🌐 %s\n" "${test_urls[@]}"
    echo

    # Run tests (only on ingress URLs)
    echo "=================================================="
    print_info "Starting Ingress URL tests..."
    echo "=================================================="

    local success_count=0
    local failed_count=0
    local total_count=${#test_urls[@]}

    for url in "${test_urls[@]}"; do
        if test_url "$url"; then
            ((success_count++))
        else
            ((failed_count++))
        fi
    done

    echo "=================================================="
    print_info "Test Results Summary:"
    print_success "Successful: $success_count/$total_count"
    if [ $failed_count -gt 0 ]; then
        print_error "Failed: $failed_count/$total_count"
    fi

    echo "=================================================="

    if [ $success_count -eq $total_count ]; then
        print_success "All Ingress URL tests passed! 🎉"
        print_info "Note: Readiness probe URLs were displayed for reference but not tested."
        exit 0
    elif [ $success_count -gt 0 ]; then
        print_warning "Partial success: $success_count out of $total_count Ingress URL tests passed."
        exit 1
    else
        print_error "All Ingress URL tests failed! Please check your ingress configuration."
        exit 1
    fi
}

# Cleanup function
cleanup() {
    # Clean up any temporary files if needed
    rm -rf /tmp/verify-e2e-* 2>/dev/null || true
}

# Set trap for cleanup
trap cleanup EXIT

# Run main function
main
```