#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
macosfetch: neofetch-like system info for macOS (bash)

Usage:
  macosfetch [--full] [--no-logo] [--color|--no-color] [--help]

Options:
  --full      Include extra fields (disk, battery, IP, load, swap).
  --no-logo   Do not print the ASCII logo.
  --color     Force ANSI colors (even if stdout isn't a TTY).
  --no-color  Disable ANSI colors.
  --help      Show this help.
EOF
}

want_full=false
want_logo=true
want_color=auto

while [[ $# -gt 0 ]]; do
  case "$1" in
    --full) want_full=true ;;
    --no-logo) want_logo=false ;;
    --color) want_color=always ;;
    --no-color) want_color=never ;;
    --help|-h) usage; exit 0 ;;
    *) echo "Unknown arg: $1" >&2; usage >&2; exit 2 ;;
  esac
  shift
done

supports_color() {
  [[ "${want_color}" == "never" ]] && return 1
  [[ "${TERM:-}" == "dumb" ]] && return 1
  [[ "${want_color}" == "always" ]] && return 0
  [[ -t 1 ]] || return 1
  return 0
}

if supports_color; then
  c_reset=$'\033[0m'
  c_dim=$'\033[2m'
  # neofetch-like yellow keys (e.g., "OS:", "Kernel:").
  c_key=$'\033[1;33m'
else
  c_reset=""
  c_dim=""
  c_key=""
fi

cmd_exists() { command -v "$1" >/dev/null 2>&1; }

join_by() {
  local sep="$1"; shift
  local out=""
  local item
  for item in "$@"; do
    [[ -z "$item" ]] && continue
    if [[ -z "$out" ]]; then out="$item"; else out+="${sep}${item}"; fi
  done
  printf '%s' "$out"
}

human_mib() {
  local bytes="$1"
  awk -v b="$bytes" 'BEGIN { printf "%.0fMiB", (b/1024/1024) }'
}

get_user_host() {
  local user host
  user="${USER:-$(id -un 2>/dev/null || echo user)}"
  host="$(scutil --get ComputerName 2>/dev/null || hostname)"
  printf "%s@%s" "$user" "$host"
}

get_os() {
  local name ver build arch
  name="$(sw_vers -productName 2>/dev/null || echo macOS)"
  ver="$(sw_vers -productVersion 2>/dev/null || echo "?")"
  build="$(sw_vers -buildVersion 2>/dev/null || echo "?")"
  arch="$(uname -m 2>/dev/null || echo "?")"
  printf "%s %s %s %s" "$name" "$ver" "$build" "$arch"
}

get_host_model() {
  sysctl -n hw.model 2>/dev/null || echo "Unknown"
}

get_kernel() { uname -r 2>/dev/null || echo "?"; }

get_uptime() {
  local boot now diff days hours mins
  # Example: { sec = 1770890428, usec = 839782 } ...
  # Avoid matching the "sec" in "usec".
  boot="$(sysctl -n kern.boottime 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="sec"){v=$(i+2); gsub(/,/, "", v); print v; exit}}' || true)"
  now="$(date +%s)"
  if [[ -n "${boot:-}" && "${boot}" =~ ^[0-9]+$ ]]; then
    diff=$((now - boot))
    days=$((diff / 86400))
    hours=$(((diff % 86400) / 3600))
    mins=$(((diff % 3600) / 60))
    local dword hword mword
    dword="days"; ((days == 1)) && dword="day"
    hword="hours"; ((hours == 1)) && hword="hour"
    mword="mins"; ((mins == 1)) && mword="min"
    if (( days > 0 )); then
      printf "%d %s, %d %s, %d %s" "$days" "$dword" "$hours" "$hword" "$mins" "$mword"
    elif (( hours > 0 )); then
      printf "%d %s, %d %s" "$hours" "$hword" "$mins" "$mword"
    else
      printf "%d %s" "$mins" "$mword"
    fi
  else
    /usr/bin/uptime | sed -E 's/.*up[[:space:]]+([^,]+),.*/\1/'
  fi
}

get_brew_packages() {
  cmd_exists brew || { echo "0 (brew)"; return; }
  local formulas casks total
  formulas="$(brew list --formula 2>/dev/null | wc -l | tr -d ' ')"
  casks="$(brew list --cask 2>/dev/null | wc -l | tr -d ' ')"
  total=$((formulas + casks))
  printf "%d (brew)" "$total"
}

get_shell() {
  local shell_name shell_ver
  shell_name="$(basename "${SHELL:-sh}")"
  shell_ver=""
  case "$shell_name" in
    zsh) shell_ver="$(zsh --version 2>/dev/null | awk '{print $2}' || true)" ;;
    bash) shell_ver="$(bash --version 2>/dev/null | head -n1 | sed -E 's/.*version ([0-9.]+).*/\1/' || true)" ;;
    fish) shell_ver="$(fish --version 2>/dev/null | awk '{print $3}' || true)" ;;
  esac
  if [[ -n "$shell_ver" ]]; then
    printf "%s %s" "$shell_name" "$shell_ver"
  else
    printf "%s" "$shell_name"
  fi
}

get_resolution_list() {
  # system_profiler is slower but reliable on macOS.
  local raw
  raw="$(system_profiler SPDisplaysDataType -detailLevel mini 2>/dev/null || true)"
  [[ -z "$raw" ]] && return 0
  echo "$raw" \
    | awk -F': ' '/Resolution:/ { if (match($2, /[0-9]+ x [0-9]+/)) { s=substr($2, RSTART, RLENGTH); gsub(/ x /, "x", s); print s } }' \
    | awk '!seen[$0]++' \
    | paste -sd, - \
    | sed 's/,/, /g'
}

get_terminal() {
  local pid comm ppid depth
  pid="${PPID}"
  depth=0
  while [[ -n "$pid" && "$pid" != "1" && $depth -lt 20 ]]; do
    comm="$(ps -p "$pid" -o comm= 2>/dev/null | awk '{print $1}' || true)"
    comm="${comm##*/}"
    ppid="$(ps -p "$pid" -o ppid= 2>/dev/null | tr -d ' ' || true)"
    case "$comm" in
      bash|zsh|fish|sh|login|sudo|env) pid="$ppid"; depth=$((depth+1)); continue ;;
    esac
    break
  done
  case "$comm" in
    Warp|WarpTerminal) echo "WarpTerminal" ;;
    Terminal) echo "Terminal" ;;
    iTerm2) echo "iTerm2" ;;
    *) echo "${comm:-Unknown}" ;;
  esac
}

get_cpu() {
  sysctl -n machdep.cpu.brand_string 2>/dev/null || sysctl -n hw.model 2>/dev/null || echo "Unknown"
}

get_gpu() {
  local raw
  raw="$(system_profiler SPDisplaysDataType -detailLevel mini 2>/dev/null || true)"
  [[ -z "$raw" ]] && { echo "Unknown"; return; }
  echo "$raw" \
    | awk -F': ' '/Chipset Model:/ { print $2 }' \
    | awk '!seen[$0]++' \
    | paste -sd, - \
    | sed 's/,/, /g'
}

get_memory() {
  local total_bytes page_size
  local pages_active pages_wired pages_compressed
  local used_bytes

  total_bytes="$(sysctl -n hw.memsize 2>/dev/null || echo 0)"
  page_size="$(vm_stat 2>/dev/null | awk '/page size of/ { gsub(/[^0-9]/,"",$8); print $8 }' || true)"
  [[ -z "$page_size" ]] && page_size=4096

  pages_active="$(vm_stat 2>/dev/null | awk '/Pages active/ { gsub(/\./,"",$3); print $3 }' || echo 0)"
  pages_wired="$(vm_stat 2>/dev/null | awk '/Pages wired down/ { gsub(/\./,"",$4); print $4 }' || echo 0)"
  pages_compressed="$(vm_stat 2>/dev/null | awk '/Pages occupied by compressor/ { gsub(/\./,"",$5); print $5 }' || echo 0)"

  used_bytes=$(( (pages_active + pages_wired + pages_compressed) * page_size ))
  printf "%s / %s" "$(human_mib "$used_bytes")" "$(human_mib "$total_bytes")"
}

get_wm_theme() {
  # Accent color + Dark mode.
  local accent style color
  accent="$(defaults read -g AppleAccentColor 2>/dev/null || echo "")"
  style="$(defaults read -g AppleInterfaceStyle 2>/dev/null || echo "Light")"
  case "$accent" in
    -1) color="Graphite" ;;
    0) color="Red" ;;
    1) color="Orange" ;;
    2) color="Yellow" ;;
    3) color="Green" ;;
    4) color="Blue" ;;
    5) color="Purple" ;;
    6) color="Pink" ;;
    *) color="Blue" ;; # macOS default in most setups
  esac
  if [[ "$style" == "Dark" ]]; then
    printf "%s (Dark)" "$color"
  else
    printf "%s (Light)" "$color"
  fi
}

get_disk_root() {
  df -H / 2>/dev/null | awk 'NR==2 { printf "%s / %s", $3, $2 }'
}

get_battery() {
  cmd_exists pmset || { echo "N/A"; return; }
  local out pct state
  out="$(pmset -g batt 2>/dev/null || true)"
  pct="$(echo "$out" | grep -Eo '[0-9]+%' | head -n1 || true)"
  state="$(echo "$out" | awk -F'; ' 'NR==2 {print $2}' || true)"
  if [[ -n "$pct" && -n "$state" ]]; then
    printf "%s; %s" "$pct" "$state"
  elif [[ -n "$pct" ]]; then
    printf "%s" "$pct"
  else
    echo "N/A"
  fi
}

get_ip() {
  local ip
  ip="$(ipconfig getifaddr en0 2>/dev/null || true)"
  [[ -n "$ip" ]] && { echo "$ip (en0)"; return; }
  ip="$(ipconfig getifaddr en1 2>/dev/null || true)"
  [[ -n "$ip" ]] && { echo "$ip (en1)"; return; }
  echo "N/A"
}

get_load() {
  uptime | awk -F'load averages:' '{gsub(/^[[:space:]]+/,"",$2); print $2}' | tr -d '\n' || true
}

get_swap() {
  sysctl -n vm.swapusage 2>/dev/null \
    | awk '{
        for (i=1; i<=NF; i++) {
          if ($i=="total") { total=$(i+2); gsub(/,/, "", total) }
          if ($i=="used")  { used=$(i+2);  gsub(/,/, "", used) }
        }
      }
      END {
        if (used != "" && total != "") printf "%s / %s", used, total;
        else print "N/A";
      }' \
    || echo "N/A"
}

user_host="$(get_user_host)"
os="$(get_os)"
host_model="$(get_host_model)"
kernel="$(get_kernel)"
uptime_str="$(get_uptime)"
packages="$(get_brew_packages)"
shell_str="$(get_shell)"
resolution="$(get_resolution_list)"
de="Aqua"
wm="Quartz Compositor"
wm_theme="$(get_wm_theme)"
terminal="$(get_terminal)"
cpu="$(get_cpu)"
gpu="$(get_gpu)"
memory="$(get_memory)"

declare -a info_lines
info_lines+=("${user_host}")
info_lines+=("${c_dim}------------------${c_reset}")
info_lines+=("${c_key}OS:${c_reset} ${os}")
info_lines+=("${c_key}Host:${c_reset} ${host_model}")
info_lines+=("${c_key}Kernel:${c_reset} ${kernel}")
info_lines+=("${c_key}Uptime:${c_reset} ${uptime_str}")
info_lines+=("${c_key}Packages:${c_reset} ${packages}")
info_lines+=("${c_key}Shell:${c_reset} ${shell_str}")
[[ -n "$resolution" ]] && info_lines+=("${c_key}Resolution:${c_reset} ${resolution}")
info_lines+=("${c_key}DE:${c_reset} ${de}")
info_lines+=("${c_key}WM:${c_reset} ${wm}")
info_lines+=("${c_key}WM Theme:${c_reset} ${wm_theme}")
info_lines+=("${c_key}Terminal:${c_reset} ${terminal}")
info_lines+=("${c_key}CPU:${c_reset} ${cpu}")
[[ -n "$gpu" ]] && info_lines+=("${c_key}GPU:${c_reset} ${gpu}")
info_lines+=("${c_key}Memory:${c_reset} ${memory}")

if $want_full; then
  info_lines+=("${c_key}Disk (/):${c_reset} $(get_disk_root)")
  info_lines+=("${c_key}Battery:${c_reset} $(get_battery)")
  info_lines+=("${c_key}IP:${c_reset} $(get_ip)")
  info_lines+=("${c_key}Load:${c_reset} $(get_load)")
  info_lines+=("${c_key}Swap:${c_reset} $(get_swap)")
fi

declare -a logo_lines_plain
declare -a logo_lines
if $want_logo; then
  logo_lines_plain+=("                    'c.")
  logo_lines_plain+=("                 ,xNMM.")
  logo_lines_plain+=("               .OMMMMo")
  logo_lines_plain+=("               OMMM0,")
  logo_lines_plain+=("     .;loddo:' loolloddol;.")
  logo_lines_plain+=("   cKMMMMMMMMMMNWMMMMMMMMMM0:")
  logo_lines_plain+=(" .KMMMMMMMMMMMMMMMMMMMMMMMWd.")
  logo_lines_plain+=(" XMMMMMMMMMMMMMMMMMMMMMMMX.")
  logo_lines_plain+=(";MMMMMMMMMMMMMMMMMMMMMMMM:")
  logo_lines_plain+=(":MMMMMMMMMMMMMMMMMMMMMMMM:")
  logo_lines_plain+=(".MMMMMMMMMMMMMMMMMMMMMMMMX.")
  logo_lines_plain+=(" kMMMMMMMMMMMMMMMMMMMMMMMMWd.")
  logo_lines_plain+=(" .XMMMMMMMMMMMMMMMMMMMMMMMMMMk")
  logo_lines_plain+=("  .XMMMMMMMMMMMMMMMMMMMMMMMMK.")
  logo_lines_plain+=("    kMMMMMMMMMMMMMMMMMMMMMMd")
  logo_lines_plain+=("     ;KMMMMMMMWXXWMMMMMMMk.")
  logo_lines_plain+=("       .cooc,.    .,coo:.")

  if supports_color; then
    # Use a simple blue gradient similar to neofetch's colored ASCII logos.
    # Keep padding based on the non-colored text (logo_lines_plain).
    declare -a logo_colors
    logo_colors+=($'\033[38;5;75m')
    logo_colors+=($'\033[38;5;75m')
    logo_colors+=($'\033[38;5;81m')
    logo_colors+=($'\033[38;5;81m')
    logo_colors+=($'\033[38;5;87m')
    logo_colors+=($'\033[38;5;87m')
    logo_colors+=($'\033[38;5;93m')
    logo_colors+=($'\033[38;5;93m')
    logo_colors+=($'\033[38;5;99m')
    logo_colors+=($'\033[38;5;99m')
    logo_colors+=($'\033[38;5;105m')
    logo_colors+=($'\033[38;5;105m')
    logo_colors+=($'\033[38;5;111m')
    logo_colors+=($'\033[38;5;111m')
    logo_colors+=($'\033[38;5;117m')
    logo_colors+=($'\033[38;5;117m')
    logo_colors+=($'\033[38;5;123m')

    for ((i=0; i<${#logo_lines_plain[@]}; i++)); do
      logo_lines+=("${logo_colors[$i]}${logo_lines_plain[$i]}${c_reset}")
    done
  else
    logo_lines=("${logo_lines_plain[@]}")
  fi
fi

max_left=0
if $want_logo; then
  for line in "${logo_lines_plain[@]}"; do
    ((${#line} > max_left)) && max_left=${#line}
  done
fi

rows=${#info_lines[@]}
if $want_logo && ((${#logo_lines[@]} > rows)); then rows=${#logo_lines[@]}; fi

for ((i=0; i<rows; i++)); do
  left=""
  left_plain=""
  right=""

  if $want_logo && (( i < ${#logo_lines[@]} )); then
    left="${logo_lines[$i]}"
    left_plain="${logo_lines_plain[$i]}"
  fi
  if (( i < ${#info_lines[@]} )); then right="${info_lines[$i]}"; fi

  if $want_logo; then
    # Do not use printf field widths with colored strings; ANSI escapes count
    # towards width but don't render, which breaks alignment.
    pad=$((max_left - ${#left_plain}))
    ((pad < 0)) && pad=0
    printf "%s%*s  %s\n" "$left" "$pad" "" "$right"
  else
    printf "%s\n" "$right"
  fi
done
