下面从**网络栈位置、实现机制、能力边界、典型场景**几个维度，把 **Proxy mode（代理模式）** 与 **Network takeover / System proxy with TUN model（基于 TUN 的全局接管）** 讲清楚。

---

## **1️⃣ 问题分析**

很多 VPN / 网络加速 / 科学上网工具都会提供两种模式：

- **Proxy mode**
- **Network takeover / System proxy with TUN**

它们的**本质区别**在于：

👉 **是否真正接管操作系统的网络出口（L3/L4），还是只做代理层（L7）**

---

## **2️⃣ 两种模式的核心定义**

| **模式**                   | **本质**                                    |
| -------------------------- | ------------------------------------------- |
| **Proxy mode**             | 应用级代理（L7），依赖系统/应用主动使用代理 |
| **Network takeover (TUN)** | 虚拟网卡接管（L3/L4），强制拦截所有流量     |

---

## **3️⃣ Proxy mode（代理模式）**

### **🔹 工作原理**

- VPN 软件**不接管网络**
- 仅启动一个本地代理服务（如 SOCKS5 / HTTP）
- 通过以下方式生效：
    - 设置 **系统代理**
    - 或应用手动配置代理

```
App ──(HTTP/SOCKS proxy)──> VPN proxy ──> Remote
```

### **🔹 网络层级**

- **OSI：L7（应用层）**
- 只能处理：
    - HTTP / HTTPS
    - SOCKS5 支持的 TCP（部分支持 UDP）

---

### **🔹 特点**

✅ **优点**

- 实现简单
- 稳定性高
- 不需要系统权限（通常无需 root / 管理员）
- 易于调试（抓包清晰）

❌ **缺点**

- ❗**不是所有流量都会走 VPN**
- 不支持：
    - ICMP（ping）
    - 非代理感知的应用
    - 某些系统服务
- 依赖：
    - 应用是否尊重系统代理
    - 是否支持 SOCKS/HTTP 代理

---

### **🔹 常见问题**

| **场景**            | **结果**    |
| ------------------- | ----------- |
| curl / browser      | ✅ 走代理   |
| Java 应用未设 proxy | ❌ 直连     |
| gRPC / TCP raw      | ❌ 或不稳定 |
| ping                | ❌          |

---

### **🔹 典型适用场景**

- 浏览器代理
- API 调试
- 开发环境
- 精细控制哪些应用走代理

---

## **4️⃣ Network takeover / System proxy with TUN model**

### **🔹 工作原理**

- 创建 **TUN 虚拟网卡**
- 操作系统将 **所有 IP 流量** 交给 VPN 程序
- VPN 程序在用户态：
    - 解析 IP 包
    - 决定是否转发 / 丢弃 / 改写
    - 再封装发送到远端

```
App
 ↓
OS TCP/IP
 ↓
TUN 虚拟网卡
 ↓
VPN 程序（用户态路由）
 ↓
Remote
```

---

### **🔹 网络层级**

- **OSI：L3 / L4**
- 处理：
    - TCP
    - UDP
    - ICMP
    - 任意协议

---

### **🔹 特点**

✅ **优点**

- **真正的“全局 VPN”**
- 所有应用强制走 VPN
- 不依赖应用是否支持代理
- 可实现：
    - Split Tunnel
    - 域名/IP 精准路由
    - 防 DNS 泄露

❌ **缺点**

- 实现复杂
- 需要更高系统权限
- 性能开销略高（用户态转发）
- 调试成本高

---

### **🔹 能力示例**

| **能力**                  | **是否支持** |
| ------------------------- | ------------ |
| ping                      | ✅           |
| gRPC / HTTP2              | ✅           |
| Java / Go / Rust 原生 TCP | ✅           |
| 系统服务                  | ✅           |
| 强制全流量                | ✅           |

---

### **🔹 TUN 的本质**

> TUN ≈ “把内核的网络出口变成一个文件描述符”

```
Kernel IP Packet
   ↓
/dev/tun
   ↓
VPN User-space Program
```

---

## **5️⃣ 两种模式对比总结表**

| **维度**         | **Proxy mode**    | **Network takeover (TUN)**    |
| ---------------- | ----------------- | ----------------------------- |
| 网络层级         | L7                | L3/L4                         |
| 是否接管系统网络 | ❌                | ✅                            |
| 是否需要应用支持 | ✅                | ❌                            |
| 支持 TCP         | ✅                | ✅                            |
| 支持 UDP         | ⚠️（部分）        | ✅                            |
| 支持 ICMP        | ❌                | ✅                            |
| 全局生效         | ❌                | ✅                            |
| 实现复杂度       | ⭐                | ⭐⭐⭐⭐                      |
| 性能开销         | 低                | 中                            |
| 常见产品         | HTTP Proxy, SOCKS | WireGuard, OpenVPN, Clash TUN |

---

## **6️⃣ 类比理解（非常重要）**

### **Proxy mode**

> 像是：

> **你告诉“某些人”走后门**

### **Network takeover (TUN)**

> 像是：

> **把整栋楼的出口换成你控制的闸口**

---

## **7️⃣ 结合你常见的 GKE / Java / 网络场景的建议**

| **场景**            | **建议** |
| ------------------- | -------- |
| Java 服务请求不稳定 | TUN      |
| gRPC / HTTP2        | TUN      |
| 本地 API 调试       | Proxy    |
| 精确控制某些域名    | Proxy    |
| 避免 DNS / IP 泄露  | TUN      |

---

## **8️⃣ 一句话总结**

> **Proxy mode = 应用愿意才走**

> **TUN mode = 不管愿不愿意都走**

如果你愿意，下一步我可以帮你 **从 Linux 内核 / TUN 设备 / VPN 实现（如 WireGuard）角度再拆一层**，或者结合你现在用的某个 VPN 软件具体分析它的实现方式。

你的理解**方向是对的，但需要一个非常关键的“工程级修正”**。

我先给**结论版**，再拆细节。

---

## **✅ 一句话结论（修正后）**

> **在「全局接管（TUN）」模式下：**

- > **命中规则的流量** → 按规则走代理 / 远端
- > **未命中规则的流量** → **走“默认策略”**
    - > 默认策略如果是 DIRECT → 就是你说的「走本地 / 国内」
    - > 默认策略如果是 PROXY → 仍然走代理

👉 **不是“天然回到本地”**，而是**是否显式配置了 DIRECT 作为兜底**

---

## **1️⃣ 正确理解「全局（TUN）」到底“全”在哪**

**全局的含义是：**

> **流量一定会先进入 Loon 的规则引擎**

而不是：

> 所有流量都一定走代理

在 TUN 模式下，真实路径是：

```
App
 ↓
iOS TCP/IP
 ↓
TUN / Packet Tunnel   ←（强制进入）
 ↓
Rule Engine（规则匹配）
 ↓
Policy（PROXY / DIRECT / REJECT）
 ↓
真实出口
```

---

## **2️⃣ 规则命中 vs 未命中（你关心的核心）**

### **情况 A：命中规则**

```
DOMAIN-SUFFIX,google.com,PROXY
```

结果：

```
google.com → PROXY → 远端
```

---

### **情况 B：**

### **没有任何规则命中**

👉 **不会“自动”走国内**

而是走：

```
FINAL, <default-policy>
```

常见配置示例：

```
FINAL,DIRECT
```

或：

```
FINAL,PROXY
```

---

## **3️⃣ 你描述的“理解”用配置语言重写**

你说的是：

> 有规则 → 走规则

> 没规则 → 走本地（国内）

**工程上等价于：**

```
# 精确规则
DOMAIN-SUFFIX,google.com,PROXY
DOMAIN-SUFFIX,openai.com,PROXY

# 兜底
FINAL,DIRECT
```

👉 **这在 Loon / Surge / Clash 里是一个“标准、正确、推荐”的模型**

---

## **4️⃣ 常见误区（非常多人会踩）**

### **❌ 误区 1：以为全局 = 所有流量都翻**

❌ 错

✅ 全局 = 所有流量**都被“接管和审查”**

---

### **❌ 误区 2：未命中规则 = 不进 VPN**

❌ 错

✅ 未命中规则 = **仍然进 VPN，只是被 DIRECT 放行**

> DIRECT ≠ 不经过 TUN

> DIRECT = **在 TUN 内决定“本地直连”**

---

### **❌ 误区 3：DIRECT = 绕过 VPN**

在 TUN 模式下：

```
DIRECT 仍然发生在 VPN 内部
```

只是：

- 不转发到远端节点
- 使用系统真实出口

---

## **5️⃣ 用你熟悉的「网关 / Kong / GKE」来类比**

### **类比 Kong Gateway**

| **Loon** | **Kong**             |
| -------- | -------------------- |
| TUN      | 所有流量先到 Gateway |
| Rule     | Route / Plugin       |
| PROXY    | 上游 Service         |
| DIRECT   | 本地 Service         |
| FINAL    | default backend      |

```
Request
 → Gateway
   → match route? yes → upstream
   → no match → default service
```

---

## **6️⃣ 一个“脑中模型”（推荐你记住）**

> **TUN 模式 =**

>

> **“所有包先到我这，我再决定放行还是转发”**

而不是：

> “要不要走 VPN”

---

## **7️⃣ 常见最佳实践（工程角度）**

### **✅ 推荐策略（你现在的理解对应这个）**

```
# 必须翻的
DOMAIN-SUFFIX,google.com,PROXY
DOMAIN-SUFFIX,github.com,PROXY

# 本地直连
GEOIP,CN,DIRECT

# 兜底
FINAL,DIRECT
```

优点：

- 国内直连（低延迟）
- 国外走代理
- 所有流量都可控
- 无 DNS 泄露

---

## **8️⃣ 总结（再压缩一遍）**

> ✔️ 你的理解**逻辑是对的**

> ❗ 但工程上要补一句：

>

> **「没命中规则 ≠ 自动走国内」**

> **「而是走你配置的 FINAL 策略」**

如果你愿意，下一步我可以帮你**画一张「TUN + Rule + FINAL」的流量 Mermaid 图**，或者结合你之前关心的 **DNS / Fake-IP / HTTP2 / gRPC** 再往下一层拆。
